---
icon: zondicons:network
date: 2026-01-04
category:
  -计算机基础408
---
# Computer Networking

## 物理层

### 基本概念

**分为导引型传输媒体和非导引型传输媒体**

导引型：

- 双绞线
- 同轴电缆
- 光纤

非导引：

- 微波通信（2-40GHz）

物理层给数据链路层提供比特流的传输服务，所以物理层考虑的是怎样才能连接各种计算机的传输媒体上传输数据比特流。

物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。

- `机械特性`：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置
- `电气特性`：指明在接口电缆的各条线上出现的电压范围
- `功能特性`：指明某条线上出现的某一电平的电压表示何种意义
- `过程特性`：指明对于不同功能的各种可能事件的出现顺序

### 传输媒体

1.同轴电缆

![image-20251109172142907](/coding_images/image-20251109172142907.png)

2.双绞线

屏蔽双绞线增加了屏蔽层，提高抗电磁干扰能力

![image-20251109172628780](/coding_images/image-20251109172628780.png)

3.光纤

![image-20251109173327651](/coding_images/image-20251109173327651.png)

4.电力线

![image-20251109173615208](/coding_images/image-20251109173615208.png)

5.电磁波

![image-20251109173729538](/coding_images/image-20251109173729538.png)

### 传输方式

**串行传输和并行传输**

串行：发送端和接收端，只有一条数据传输线路，数据一个一个传。

并行：多条数据链路共同跑，一次发送n个比特

![image-20251109174412727](/coding_images/image-20251109174412727.png)

远距离传输用串行，计算机内部传输使用并行。

**同步传输和异步传输**

![image-20251109174617740](/coding_images/image-20251109174617740.png)

异步传输是**发送方和接收方的时钟不同步**，每一次只传输一个字节或字符，每一个字符都有自己的起始位和停止位来标识边界。==字节间异步，比特间同步==

同步传输是**发送端和接收端共享统一的时钟节奏**，没有起始位和停止位

**单向通信（单工）和双向交替通信（半双工）和双向同时通信（全双工）**

- 单工：单向通信，通信双方只有一个传输方向（广播）

- 半双工：双向通信，但是不能两个传输方向不能同时通信（对讲机）

- 全双工：双方可同时通信和接收（电话）

### 编码与调制

消息->数据->信号->基带信号

![image-20251110134443314](/coding_images/image-20251110134443314.png)

- 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形

![image-20251110134609670](/coding_images/image-20251110134609670.png)

单工传输，传输媒体就一个发送信道

双工or半双工，传输媒体有发送信道和接收信道

编码：将数字信号转换为另一种数字信号，在数字信道中进行传输，或将模拟信号转换为数字信号，在数字信道中传输。

- 不归零编码（NRZ）：不出现零电平，存在同步问题。整个码元时间内电平不发生变化，需要额外的传输线来传输时钟信号。
- 归零编码(RZ)：自同步，每次信号结束都要归零导致浪费，编码效率很低，接收方只需要在归零后进行采样，不需要单独的时钟信号。
- 曼彻斯特编码：传统以太网的编码，看跳变。
- 差分曼彻斯特编码：比曼彻斯特编码变化更少，更适合较高的传输速率，在码元中间时刻发生电平跳变，跳变表示时钟，码元开始后的变化表示数据。发生变化表示0，不发生变化表示1。

![image-20251110135038226](/coding_images/image-20251110135038226.png)

调制：将数字信号转为模拟信号，在模拟信道中传输或模拟信号转换为另一种模拟信号，在模拟信道中传输都叫调制。

![image-20251110135209221](/coding_images/image-20251110135209221.png)

==以上是基本调制方法，1个码元只能包含1个比特信息，要使1个码元包含更多比特，可以使用混合调制==

eg：正交振幅调制QAM

![image-20251110135535163](/coding_images/image-20251110135535163.png)

**每个码元与比特的关系不能随便定义，需要遵循格雷码**

![image-20251110135630276](/coding_images/image-20251110135630276.png)

### 信道的极限容量

造成信号失真的因素：码元传输速率，信号传输距离，噪声干扰，传输媒体质量。

当失真严重时，输出信号无法判断识别0和1

**奈氏准则**：在假定理想条件下，为了避免码间串扰，码元传输速率是由上限的。

**码元最大传输速率（波特率）= 2 × 链路带宽**

![image-20251110150036806](/coding_images/image-20251110150036806.png)

**香农公式：**带宽受限且有高斯白噪声干扰的信道的极限信息传输速率

![image-20251110181550433](/coding_images/image-20251110181550433.png)

- 在信道带宽一定的情况下，根据奈氏准则和香农公式，想要提高信息的传输速率就必须采用多元制和努力提高信道中的信噪比。
- 自从香农公式发表后，各种新的信号处理和调制方法不断出现，都是为了尽可能接近传输速率极限
- ==注意分贝表示信噪比和信噪比的区别！！！==

==信号传播速度不影响数据传输速率，信噪比，带宽，调制速度都会影响== 

![image-20251110192827460](/coding_images/image-20251110192827460.png)

==**每个码元的比特数 = log2(码元总数)**==

只需关心能调出几种不同的波形即可

![image-20251110194224217](/coding_images/image-20251110194224217.png)

 ![image-20251110194600052](/coding_images/image-20251110194600052.png)

![image-20251110194611085](/coding_images/image-20251110194611085.png)

无噪声用奈氏准则+调制方式，有噪声使用香农公式计算

![image-20251110194835554](/coding_images/image-20251110194835554.png)

### 物理层习题

![image-20251112090916125](/coding_images/image-20251112090916125.png)

![image-20251112091004830](/coding_images/image-20251112091004830.png)

MAC地址（物理地址）是数据链路层

## 数据链路层

### 基本概述

![image-20251112092312713](/coding_images/image-20251112092312713.png)

- 链路（link）：从一个结点到相邻节点的一段物理线路，而中间没有任何其他的交换节点。
- 数据链路：指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。

- 数据链路层以帧为单位传输数据

**数据链路层的三个重要问题**：

==封装成帧、差错检测（检测帧传输过程中是否出现误码）、可靠传输==

可靠传输：尽管误码不能完全避免，但若能实现发送方发送什么，接收方就接受什么，就称为可靠传输。

以太网的媒体接入控制协议：CSMA/CD

### 封装成帧

概念：数据链路层给上层教辅的协议数据单元添加帧头帧尾使之成为帧

- 帧头帧尾包含重要信息
- 特定数值帧头和帧尾的作用之一就是帧定界（）

- 透明传输：数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。

- 面向字节的物理链路使用字节填充的方法实现透明传输。

- 面相比特的物理链路层使用比特填充的方法实现透明传输

  

![image-20251113140614440](/coding_images/image-20251113140614440.png)

如果传输数据恰好有和帧定界一样的内容，则无法实现传输，所以协议会避免这个问题，在传输之前进行扫描，在帧定界字符后加上转义字符，让接收方明白是数据内容而非定界符。

零比特填充：每五个比特一后面插入一个比特0

- 为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些
- 考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU

![image-20251113144843310](/coding_images/image-20251113144843310.png)

### 差错检测

- 实际通信连路不是理想的，比特在传输过程中可能产生差错，1可能变成0,0也可能变成1，成为比特差错
- 误码率（BER）：在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER
- 使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一
- FCS字段是检测误码的

![image-20251114103025005](/coding_images/image-20251114103025005.png)

 **奇偶校验：**

- 在待发送的数据后面添加1位奇偶校验位，使整个数据（包含奇偶校验位在内）中“1”的个数为奇数或偶数
- ![image-20251114110821342](/coding_images/image-20251114110821342.png)
- ![image-20251114110911363](/coding_images/image-20251114110911363.png)
- 如上图，如果偶数个数据发生误码，则会漏检，所以一般不会用这个

**循环冗余校验**：（CRC）

- 收发双方约定好一个生成多项式
- 发送方基于待发送的数据和多项式计算出差错检测码，将其添加到待传输数据的后面一起传输。
- 接收方通过生成多项式来计算收到的数据是否产生了误码。

![image-20251115114916787](/coding_images/image-20251115114916787.png)

![image-20251115114948848](/coding_images/image-20251115114948848.png)

具体算法：

![image-20251115115343023](/coding_images/image-20251115115343023.png)

![image-20251115115411517](/coding_images/image-20251115115411517.png)

  ![image-20251115115914769](/coding_images/image-20251115115914769.png)

说明：

- 检错码只能检测出帧在传输过程中出现的差错，但是不能定位错误，所以也无法纠正错误
- 要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但是纠错码的开销比较大，在计算机网络中较少使用
- CRC有很好的检错能力（漏检率低），计算复杂，但是易于硬件实现，因此广泛应用于数据链路层。
- 在计算机网络中通常采用我们后续课程中将要讨论的检错重传方式来纠正传输过程中的差错或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向上层提供的是可靠传输服务还是不可靠传输服务。

### 可靠传输

- 使用差错检测技术，接收方的数据链路层就可以检测出帧在传输过程中是否产生了误码
- 对于数据链路层向上层提供的服务，分为可靠传输和不可靠传输服务
- 不可靠：仅仅丢弃有误码的帧，其他什么也不做
- 可靠：想办法实现发送端发送什么，接收端就收到什么。

![image-20251115121152234](/coding_images/image-20251115121152234.png)

可靠传输比较复杂，开销大，是否采用可靠传输要看情况。

三种可靠传输协议：

#### 停止等待协议（SW）

 一共四个图，语言描述如下：

- 正常情况：发送方发送数据，接收方接受后返回ACK，表示接收到了数据，若发送方产生了误码，则接收方会返回一个NAK，然后发送方重新传数据，接收方反馈。
- 超时重发：假如说发送方data在传输过程中丢失，那接收方也不会无缘无故的相应，所以需要有超时重传机制，若发送方长时间收不到响应，就重新传数据，接收方接受数据后给响应
- 确认丢失：假若ack进行了丢失，则发送方收不到ack会超时重发，这样的话接收方就会收到两个重复信息，此时接收方会检测重复，然后丢弃，返回ack到发送方。==为了避免分组重复导致的传输错误，必须给每个分组都带上序号，这样可以让接收方明白是是否重复分组==
- 确认迟到：发送方发送数据，接收方返回的ack迟到了，导致触发了超时重传机制，发送方重新发送DATA0数据，接收方接受后丢弃发送ack，但此时ack到达发送方，发送方于是发送DATA1数据，接收方发送ack，此时两个ack都到达发送方，发生方无法判断是否是重复数据发出，所以ACK也需要进行编号，接收到重复的ACK后发送方直接忽略，继续发送数据即可。

![image-20251115125708331](/coding_images/image-20251115125708331.png)

注意事项：

![image-20251115130040309](/coding_images/image-20251115130040309.png)

![image-20251115130151836](/coding_images/image-20251115130151836.png)

![image-20251115155051631](/coding_images/image-20251115155051631.png)

注：一字节等于8bit

- 当往返延时RTT远大于数据帧发送时延Td时，信道利用率非常低
- 若出现重传，则对于有用的数据信息来说，信道利用率更低了
- 为了克服停止-等待协议信道利用率低的问题，产生了下面两种协议

==此协议也叫 ARQ(Automatic repeat request)自动请求重传协议==

#### 回退N帧协议（GBN）

1.采用三个比特给分组进行编号，序号为0-7；

2.发送窗口的尺寸Wt的取值为：`1<Wt<=2的三次方-1`

3.接受窗口尺寸为1

4.传到k就会返回ack[k]

**通过滑动窗口的形式进行传输**

![image-20251115172412132](/coding_images/image-20251115172412132.png)

如果发送窗口的尺寸超过上限的话，比如上限为7，但尺寸取成了8，如果ack7传输过程产生丢失，发送方超时重传，则接收方因为发送窗口超过上限，无法判断是否为重复接收信息。故==发送方窗口一定不能超过上限==

![image-20251115173236280](/coding_images/image-20251115173236280.png)

![image-20251115173714148](/coding_images/image-20251115173714148.png)

 ==回退N帧协议是一种连续ARQ协议，又称为滑动窗口协议，当通信线路质量不好的时候，其信道利用率并不比停止等待协议高。==

#### 选择重传协议（SR）

![image-20251115174354767](/coding_images/image-20251115174354767.png)

 工作原理（有点复杂，不好描述，使用ai帮我记笔记）：

------

⭐ **选择重传协议 Selective Repeat (SR) — 笔记**

选择重传（Selective Repeat, SR）是数据链路层一种可靠传输协议，是滑动窗口协议的进阶版本。它通过 **选择性重传出错帧**，提升带宽利用率，比回退 N 帧（GBN）更高效。

------

1. SR 协议的主要思想

- 接收方 **只拒绝出错帧**，其余帧正确接收并缓存。
- 发送方 **只重传**那些被判定丢失或出错的帧。
- 双方使用 **滑动窗口机制** 控制允许发送/接收的序号范围。
- 序号空间必须足够大（常见要求：序号长度 ≥ 2 * 窗口长度）。

特点总结：

| 协议     | 是否缓存乱序帧 | 出错后是否要回退   | 利用率 |
| -------- | -------------- | ------------------ | ------ |
| 停止等待 | 无             | 是（就一帧）       | 最低   |
| GBN      | 不缓存         | 是（回退到出错帧） | 中等   |
| SR       | 缓存乱序帧     | 不回退             | 最高   |

------

2. SR 协议的发送方机制

发送窗口大小：`W`
 序号空间大小：`N`

发送方维持：

1. **send_base**：窗口起始序号
2. **next_seq_num**：下一个可发送的序号
3. **计时器数组**：每个未确认帧均有一个独立计时器

发送步骤：

1. 若 `next_seq_num` 在发送窗口内，则构建并发送数据帧。
2. 为该帧启动一个专属计时器。
3. 接收到 **ACK(n)**：
   - 标记帧 n 已被确认。
   - 若 n 是窗口基序号，则滑动窗口（向前移动）。
4. 若某帧计时器超时：
   - **只重传该帧**（SR 的关键点）。

------

3. SR 协议的接收方机制

接收窗口大小：一般等于发送窗口大小 `W`。

接收方维持：

1. **recv_base**：接收窗口起始序号
2. **buffer[]**：缓存乱序帧

处理步骤：

1. 如果收到的帧 seq 在接收窗口内：
   - 缓存该帧
   - 返回 ACK(seq)
   - 若 seq 恰好为 recv_base，则将连续多个已缓存帧交付给上层，并滑动窗口
2. 如果 seq 落在 **下一个窗口**（已确认过的序列范围）：
   - 可能是重传 ACK 的场景 → 再发 ACK(seq)
3. 其他：忽略

接收方 ACK 策略：

- **每收到一个合法帧就发送 ACK**（即使帧乱序）
- ACK 仅确认对应帧，不采用累计确认

------

4. 窗口大小与序号空间的关系

**SR 的重点：为了避免新旧帧混淆，要求：**

![image-20251115175321430](/coding_images/image-20251115175321430.png)

理由：

若窗口过大，例如 `W > N/2`，则新窗口中的序号可能等于之前窗口中的序号，导致接收方错误接受过期帧。

示例：

- 序号空间：0~7（N = 8）
- 最大窗口：W = 4（允许）

------

5. SR 与 GBN 的对比补充

| 特性       | GBN          | SR                         |
| ---------- | ------------ | -------------------------- |
| 接收乱序帧 | ❌ 不缓存     | ✔ 缓存                     |
| ACK 类型   | 累计确认     | 单独确认                   |
| 出错处理   | 回退到出错帧 | 只重传出错帧               |
| 计时器     | 只有一个     | 每帧一个                   |
| 适用场景   | 链路较稳定   | 高延迟、高误码、需要高吞吐 |

SR 更复杂，但更高效。

------

6. SR 的优点与缺点

⭐ 优点：

1. **高带宽利用率**
2. 无需重复发送已正确接收的帧
3. 在误码率较高的场景性能领先 GBN

❗ 缺点：

1. 实现复杂度高，需要：
   - 缓存乱序帧
   - 每帧独立定时器
   - 更大的序号空间
2. 窗口和序号关系必须满足：W ≤ N/2

------

7. 一个简单例子

假设：

- 序号空间：0~7
- 窗口大小：4
- 要发送的数据帧序号：0 1 2 3 4 5 6 7

过程：

1. 发送方发送 0,1,2,3
2. 接收方收到 0,2,3（1 丢失）：
   - 缓存 2、3，不上交
   - ACK(0), ACK(2), ACK(3)
3. 发送方定时器发现 1 超时 → 重传 1
4. 接收方收到 1 → 缓存完整 0~3 → 一次性交付 → 窗口移到 4
5. 后续循环

![image-20251115193336476](/coding_images/image-20251115193336476.png)

### 点对点协议（PPP）

- 点对点协议PPP（Point-to-point Protocol）是目前使用最广泛的点对点数据链路层协议。

帧格式：

![image-20251115194142286](/coding_images/image-20251115194142286.png)

![image-20251115195230749](/coding_images/image-20251115195230749.png)

![image-20251115195243829](/coding_images/image-20251115195243829.png)

差错检测：FCS字段，进行CRC检验

![image-20251115195402420](/coding_images/image-20251115195402420.png)

### 媒体接入控制 

基本概念：

- 共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC（Medium Access Control）
- 可分为静态划分信道和动态接入控制

![image-20251116154703681](/coding_images/image-20251116154703681.png)

​         随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术

#### 静态划分信道

信道复用：

- 复用就是通过一条物理系路同时传输多路用户的信号
- 当网络中传输媒体的传输容量大于多条单一信道传输的总信道量时，可以利用复用技术在一条物理线路上建立多条通信信道来充分传输媒体的带宽。

![image-20251116160336566](/coding_images/image-20251116160336566.png)

 ①频分复用（FDM）

**同时占用不同的频带资源并行通信**

![image-20251116160617694](/coding_images/image-20251116160617694.png)

②时分复用（TDM）

**时分复用的所有用户在不同的时间占用同样的频带宽度**

![image-20251116160746545](/coding_images/image-20251116160746545.png)

③波分复用（WDM）

==光信号的频分复用==

![image-20251116160935632](/coding_images/image-20251116160935632.png)

④码分复用（CDM）

![image-20251116161446838](/coding_images/image-20251116161446838.png)

![image-20251116161547556](/coding_images/image-20251116161547556.png)

接收方判断哪个站点发送了什么数据的方法：

用接受到的数据与站点数据点积，如果计算数值为1，则判断方发送了比特1，如果计算结果为-1，则判断方发送了比特0，如果计算数值为0，则判断方未发送信息。

![image-20251116161930660](/coding_images/image-20251116161930660.png)

![image-20251116162822955](/coding_images/image-20251116162822955.png)

#### 随机接入-CSMA/CD

载波监听多址接入 随机碰撞（CSMA/CD协议）

解释：

- 多址接入（MA）：多个站连在一条总线上，竞争使用总线
- 载波监听（CS）：每一个站在发送帧之前要先检测一下总线上是否有其他站点在发送帧。若检测到总线空闲96比特时间，则发送这个帧，若检测到总线忙，则继续检测并等待总线转为空闲96比特，然后发送这个帧
- 碰撞检测（CD）：每一个正在发送帧的站边发送变检测碰撞，一旦发现总线上出现碰撞，则立即停止发送，避退一段时间后再次发送。

![image-20251116163641717](/coding_images/image-20251116163641717.png)

争用期（碰撞窗口）：

概念:

以太网中各站点物理距离可能很远，如果 A 开始发送，B 过了一段时间才检测到，再开始发送，这两者的信号可能在中间相撞。

为了保证：

- **即便两个站点在网络的最远端**
- **也能在帧发送的前一段时间内检测到冲突**

以太网规定：**帧的长度要足够长，使得在“信号传播最大往返时间内”，冲突都能被检测到。**

![image-20251116165115863](/coding_images/image-20251116165115863.png)

最小帧长：

以太网规定，帧长不能太短，是为了在帧发完之前检测到冲突或碰撞。

如果帧长太短，当发生碰撞时，发送方已经发送完毕，无法检测是否发生碰撞，导致数据丢失。

- 以太网规定最小帧长为64字节，即512比特
- 如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。
- 以太网最小帧长确保了主机可以在帧发送完之前就检测到该帧的发送过程中是否遭遇了碰撞。
- 如果争用期内未发生碰撞，那么后续发送的数据就一定不发生碰撞；
- 如果发生碰撞，就立即停止发送，==凡是长度小于64字节的帧都是由于碰撞而异常中止的无效帧。== 

**截断二进制指数退避算法：**

![image-20251116202749789](/coding_images/image-20251116202749789.png)

![image-20251116202922576](/coding_images/image-20251116202922576.png)

![image-20251116203101927](/coding_images/image-20251116203101927.png)

![image-20251116203245880](/coding_images/image-20251116203245880.png)

![image-20251116203429759](/coding_images/image-20251116203429759.png)

![image-20251116203644366](/coding_images/image-20251116203644366.png)

![image-20251116203824287](/coding_images/image-20251116203824287.png)

#### CSMA/CA

全称：载波监听多址接入/碰撞避免 （Carrier  Sense Multiple Access/Collision Avoidance）

在无线局域网中，不适用碰撞检测（CD）：

- 由于无线信道 的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接受到的信号强度往往会远小于发送信号的强度。**如果要在无线网卡上实现碰撞检测，对硬件要求极高**
- 无线电波传播存在隐蔽站问题，进行碰撞检测的意义不大

隐蔽站问题：

![image-20251121111438756](/coding_images/image-20251121111438756.png)

CSMA/CA:

- **802.11无线局域网使用CSMA/CA协议**，在CSMA的基础上增加了避免碰撞CA，而不实现碰撞检测功能。
- **由于不可能避免所有碰撞，且无线信道误码率较高**，802.11**标准还使用了**，**数据链路确认机制（停止等待协议）**来保证数据被正确接收
- 802.11的MAC层标准定义了两种媒体接入方式：
  - 分布式协调功能DCF，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权。这个是默认方式。
  - 点协调功能PCF，PCF方式使用集中控制的接入算法（一般在接入点AP实现集中控制），这个是可选方式

==所有站点必须在持续检测到信道空间一段时间后才能发送帧，这段时间称为帧间间隔IFS==

帧间间隔的长短取决于发送帧的优先级：

- 高优先级帧帧间间隔比较短。
- 低优先级帧间间隔略长，要等到其他站的高优先级发送后，信道变为忙态，低优先级推迟发送，这样可以减少碰撞的机会。

![image-20251121172803613](/coding_images/image-20251121172803613.png)

![image-20251121173146040](/coding_images/image-20251121173146040.png)

![image-20251121173414638](/coding_images/image-20251121173414638.png)

使用情况：

- 当站点检测到 信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。
- 必须使用退避算法的情况：
  - 1.在发送数据帧之前信道处于忙状态
  - 2.在每一次重传一个数据帧的时候
  - 3.在每一次成功发送后要连续发生下一个帧的时候。（怕碰撞）

 ![image-20251121174100607](/coding_images/image-20251121174100607.png)

![image-20251121174311977](/coding_images/image-20251121174311977.png)

![image-20251121174735193](/coding_images/image-20251121174735193.png)

![image-20251121174830764](/coding_images/image-20251121174830764.png)

![image-20251121175014756](/coding_images/image-20251121175014756.png)

![image-20251121175128848](/coding_images/image-20251121175128848.png)

![image-20251121175643894](/coding_images/image-20251121175643894.png)

![image-20251121175906398](/coding_images/image-20251121175906398.png)

### MAC地址

- MAC地址是以太网的MAC子层所使用的地址
- IP地址是TCP/IP体系网际层所使用的地址
- ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址
- =="MAC地址"是物理地址，是每个网络接口的唯一标识，"ip"是网络地址，是在网络中用于寻找设备的位置。ARP是将两个对应起来的协议==

MAC地址：
    **帧中必须携带标识发送主机和接收主机的地址** Media Access Control

![image-20251121201551638](/coding_images/image-20251121201551638.png)

 **MAC地址又叫物理地址，但是不属于物理层**

![image-20251121202651404](/coding_images/image-20251121202651404.png)

![image-20251121203119996](/coding_images/image-20251121203119996.png)

字节发送顺序： 第一字节到第六字节

字节内比特发送顺序：b0-b7

 随机MAC地址：反侦察所用

### IP地址

- 网络编号：标识因特网上数以百万计的网络
- 主机编号：标识同一网络上不同主机（或路由器各接口）

- 如果只是一个单独的网络，不接入因特网，可以只使用MAC地址
- 但是如果接入因特网，那IP和MAC都要用。

![image-20251129152319011](/coding_images/image-20251129152319011.png)

- 数据包转发过程中源IP地址和目的IP地址保持不变；
- 数据报转发过程中源MAC地址和目的MAC地址逐个链路（或者逐个网络）改变。

![image-20251129153300245](/coding_images/image-20251129153300245.png)

### ARP协议

**IP地址 -> MAC地址 通过ARP协议进行解析**

在帧的传输过程中，发送数据包时，需要发送目标的MAC地址，但是发送方只知道IP地址不知道MAC地址，所以需要使用ARP协议进行解析得到MAC地址。

每个主机都有ARP高速缓存表

![image-20251129153654058](/coding_images/image-20251129153654058.png)

![image-20251129162535935](/coding_images/image-20251129162535935.png)

![image-20251129162650376](/coding_images/image-20251129162650376.png)

根据ARP高速缓存表，可以继续发数据包

==需要注意的是ARP协议只能在一段链路或者同一网络中使用，不能跨网络==

![image-20251129162832676](/coding_images/image-20251129162832676.png)

### 集线器和交换机的区别

![image-20251129163354372](/coding_images/image-20251129163354372.png)

![image-20251129163515038](/coding_images/image-20251129163515038.png)

集线器需要把收到的帧发送给网络中所有的主机，但是交换机会直接发送到目的主机

**以太网交换机**

- 以太网交换机通常由多个接口。多个接口都可以直接与一台主机或者另一个以太网交换机相连。一般都在工作在全双工方式。
- 以太网交换机具有并行性，能同时连通多对接口，使多对主机能够同时通信，无碰撞。
- 以太网交换机一般有多种速率的接口 10Mb/S,100mMb/S,1Gb/s.等多种组合
- 以太网交换机工作在数据链路层，它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口进行转发帧
- 以太网交换机是一种即插即用的设备，其内部的帧交换表是通过，**自学习算法**自动的逐渐建立起来的

![image-20251129165316042](/coding_images/image-20251129165316042.png)

![image-20251129165325795](/coding_images/image-20251129165325795.png)

==从效果上看，广播帧的发送，二者没有区别；但是单帧的发送上，交换机有明显的优势：不会碰撞且方便==

![image-20251129170059362](/coding_images/image-20251129170059362.png)

![image-20251129170129974](/coding_images/image-20251129170129974.png)

### 以太网交换机自学习和转发帧

![image-20251129170844011](/coding_images/image-20251129170844011.png)

定期 自动删除：==MAC地址与交换机接口的对应关系并不是永久性的==

PDU：协议数据单元，它是计算机网络体系结构中对等实体之间的逻辑通信的对象

![image-20251129171616630](/coding_images/image-20251129171616630.png)

### 以太网交换机的生成树协议STP

如何提高以太网的可靠性？

--一般来说可以通过增加荣誉链路的方式

![image-20251129172613913](/coding_images/image-20251129172613913.png)

但是会有以下问题：

- 广播风暴：**通信过程会形成死循环，大量浪费网络资源**
- 主机会收到重复的广播帧：**会大量消耗主机资源**
- 交换机的帧交换表震荡：**不断的修改错误MAC地址和接口表，形成死循环**

于是生成树协议（STP）用来解决这个问题：

![image-20251129173002771](/coding_images/image-20251129173002771.png)

### 虚拟局域网VLAN

在以太网通过交换机不断扩大，连接以后，会有很多弊端：

- 广播风暴：浪费资源，浪费主机CPU资源（非必要不广播，但是TCP/IP协议很多都需要广播）

==分割广播域可以使用路由器，但是成本过高==

- 难以维护管理
- 潜在安全问题

所以VLAN（Virtual Local Area Network）是一种将局域网内的设备划分与物理位置无关的逻辑组技术，这些逻辑组具有某些共同的需求。

实现机制：

![image-20251201184027951](/coding_images/image-20251201184027951.png)

![image-20251201184133769](/coding_images/image-20251201184133769.png)

![image-20251201184756168](/coding_images/image-20251201184756168.png)

![image-20251201185109020](/coding_images/image-20251201185109020.png)

## 网络层（笔记丢失，只有图片，悲）

![image-20251227213230961](/coding_images/image-20251227213230961.png)

![image-20251227213422845](/coding_images/image-20251227213422845.png)

![image-20251227213700531](/coding_images/image-20251227213700531.png)

![image-20251227213949220](/coding_images/image-20251227213949220.png)

![image-20251227214152890](/coding_images/image-20251227214152890.png)

![image-20251227214307908](/coding_images/image-20251227214307908.png)

![image-20251227214501398](/coding_images/image-20251227214501398.png)

![image-20251227215152224](/coding_images/image-20251227215152224.png)

![image-20251227221408300](/coding_images/image-20251227221408300.png)

![image-20251227221618303](/coding_images/image-20251227221618303.png)

![image-20251227221842838](/coding_images/image-20251227221842838.png)

![image-20251227223310068](/coding_images/image-20251227223310068.png)

![image-20251227223419173](/coding_images/image-20251227223419173.png)

![image-20251227223752116](/coding_images/image-20251227223752116.png)

![image-20251227224009895](/coding_images/image-20251227224009895.png)

![image-20251227225101242](/coding_images/image-20251227225101242.png)

![image-20251227225717269](/coding_images/image-20251227225717269.png)

### IPv4地址的应用

![image-20251228120005967](/coding_images/image-20251228120005967.png)

定长的只能划分有限且固定的IP地址，会导致IP地址严重浪费

变长：

![image-20251228120355049](/coding_images/image-20251228120355049.png)

### IP数据报发送和转发过程

![image-20251228122757744](/coding_images/image-20251228122757744.png)

​    首先先把目的地址与自己的子网掩码相与运算，然后若结果是本主机的子网，就直接交付传输即可，若不在，就要通过网关找到路由器，然后把数据传给路由器，路由器收到源ip地址和目的IP地址后，进行判断首部是否出错，若出错直接丢弃，若不出错就转发，在路由表中找下一跳，然后传到目的地址以后，目的主机进行处理。

 ==路由器是隔离广播域的，不会转发广播==

![image-20251228123345190](/coding_images/image-20251228123345190.png)

![image-20251228123551090](/coding_images/image-20251228123551090.png)

会丢弃的！！！！

![image-20251228124241462](/coding_images/image-20251228124241462.png)

**静态路由配置的环路问题**

人工配置只适用于小规模网络

![image-20251228141022078](/coding_images/image-20251228141022078.png)

为了简化路由表，对于具有相同下一跳的不同目的网络的路由条目，可以设置==默认路由条目==，即0.0.0.0，==网络前缀最短，最模糊==

==特定主机路由==：用于测试，可以在路由表中添加特定主机ip地址，==网络前缀最长，最具体==

最长前缀匹配原则：有多条路由可以选择时，选择==最长前缀匹配==

**路由环路：**

![image-20251228141622293](/coding_images/image-20251228141622293.png)

解释：当某一个路由表的下一跳出错的时候，数据会传到错误地址上去，在错误的路由器上进行查询转发又发会回来，由此往复，本来r2要传到r1的，结果r2传r3，r3传r2，陷入死循环，这就是所谓路由环路问题

**解决**:IP数据报首部设置生存时间TTL字段，IP数据报进入路由器后，TTL字段会减一，当TTL字段减一后端值不为0才正常转发，不然就丢弃。

![image-20251228142749024](/coding_images/image-20251228142749024.png)

当转发了不存在的子网络的时候，也会有相似的问题，也是路由环路

**解决：**添加黑洞路由，下一跳为NULL，若目的网络位次，直接丢弃，有去无回

![image-20251228142856990](/coding_images/image-20251228142856990.png)

若某网络出现故障，也会导致路由表中目的网络丢失，产生路由环路问题

**解决**：设置黑洞路由

### 路由选择

静态和动态

路由选择协议：

![image-20251228152754738](/coding_images/image-20251228152754738.png)

开放路径优先OSPF

- 开放：表示公开发表，不受一家厂商控制
- 最短路径优先：使用dijkstra提出的最短路径算法SPF

![image-20251228201224659](/coding_images/image-20251228201224659.png)

- OSPF相邻路由器之间通过交互问候分组，建立和维护邻居关系
  问候分组：

![image-20251228201638278](/coding_images/image-20251228201638278.png)

- 使用OSPF的每一个路由器都会产生LSA（链路状态通告）。LSA包含直连网络的链路状态信息和邻居路由器的链路状态信息
- LSA被封装在链路状态更新分组LSU中，采用洪泛法进行发送

![image-20251228201959379](/coding_images/image-20251228201959379.png)

大概梳理：

物理网络拓扑 -> 生成每台路由器的LSDB（链路状态数据库） -> 可以得到带权有向图 -> dijkstra算法算出最短路径

ospf类型：

- 问候分组：用来发现和维护邻居路由器
- 数据库描述分组：向邻居描述自己的链路状态数据库中的所有链路状态项目的摘要信息
- 链路状态请求分组：向邻居路由器请求某些链路状态项目的详细信息
- 链路状态更新分组：路由器使用这种分组将其链路状态进行洪泛发送，即使用洪泛法对全网更新链路状态。
- 链路状态确认分组：对链路状态更新的确认分组。

OSPF基本工作过程：

![image-20251228203442547](/coding_images/image-20251228203442547.png)

OSPF在多点接入网络中路由器邻居关系的建立

![image-20251228203753059](/coding_images/image-20251228203753059.png)

==为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域。==

![image-20251228204050723](/coding_images/image-20251228204050723.png)

边界路由器ABR会向主干区域发送自己区域的LSA，向自己区域发送其他区域的LSA

**外部网关协议**

指区域和区域之间的路由传输协议

![image-20251228221848632](/coding_images/image-20251228221848632.png)

最佳路由无意义，因为没有度量

必须考虑相关策略（政治、经济等）

所以BGP 只能力求寻找一条能够达到目的网络且比较好的路由（不兜圈子）

![image-20251228222227896](/coding_images/image-20251228222227896.png)

BGP-4协议之下的四种报文：

- OPEN（打开）报文：用来与相邻的另一个BGP发言热建立关系，使通信初始化
- UPDATE报文：用来通告某一路有的信息，以及要撤销的多条路由
- KEEPALIVE(保洁)报文：用来周期性的证实邻站的连通性。
- NOTIFICATON（通知）报文：用来发送检验到的差错

![image-20251228223109186](/coding_images/image-20251228223109186.png)

### IPv4数据报的首部格式

![image-20251228223316675](/coding_images/image-20251228223316675.png)

![image-20251228224535681](/coding_images/image-20251228224535681.png)

![image-20251228224646238](/coding_images/image-20251228224646238.png)

数据载荷长度 == 总长度 - 首部长度

![image-20251228224947390](/coding_images/image-20251228224947390.png)

![image-20251228225127836](/coding_images/image-20251228225127836.png)

==注意片偏移字段的值以8字节为单位，且必须为整数==

**IP数据报的分片过程**

![image-20251228225517427](/coding_images/image-20251228225517427.png)

继续拆分IP数据报首部

![image-20251228225628526](/coding_images/image-20251228225628526.png)

TTL是为了避免路由环路

![image-20251228225834297](/coding_images/image-20251228225834297.png)

**首部检验和**：

将 IPv4 首部按 16 位分组（校验和字段置 0）进行一补码加法求和，若产生进位则回卷相加，最后对结果取 16 位一补码，使得接收端对整个首部求一补码和的结果为全 1（0xFFFF）。

![image-20251228231336586](/coding_images/image-20251228231336586.png)

 ![image-20251228232016810](/coding_images/image-20251228232016810.png)

![image-20251228232411549](/coding_images/image-20251228232411549.png)

### 网际控制报文协议ICMP

作用：为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用ICMP（Internet Control Message Protocol）

主机或路由器使用ICMP来发送==差错报告报文==和==询问报文==

ICMP封装在IP数据报中

五种报文类型：

- 终点不可达：路由器或主机不能交付数据报的时候，就向源点发送终点不可达报文
- 源点抑制：当路由器或主机由于拥塞而丢弃数据报时发送源点抑制
- 时间超过：当路由器收到一个目的IP地址不是自己的IP数据报，会将TTL字段-1，若不为0，则将该数据报转发出去；若为0，除了丢弃，还要发送时间超过报文。
- 参数问题：当路由器或IP数据报中，根据其首部中的检验字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题。
- 改变路由：路由器把改变路由发给主机，让主机知道下一次将数据报发送给另外的路由器（可以通过更好的路由）

![image-20251228234709472](/coding_images/image-20251228234709472.png)

**icmp常用询问报文**

![image-20251228235011276](/coding_images/image-20251228235011276.png)

ICMP应用举例

PING和traceroute

**Ping**

- 用来测试主机或路由器间的连通性
- 应用层直接使用网际层的ICMP
- 使用ICMP回送请求的回答报文

**Traceroute**

- 用来测试IP数据报从源主机到达目的主机要经过哪些路由器
- Windows版本：Tracert，应用层直接使用ICMP，使用了ICMP回送请求和回答报文以及差错报文
- Unix：traceroute命令，在运输层使用UDP协议，仅使用ICMP差错报告报文
- ==通过ICMP回送请求/回答报文来实现==

## 运输层

前面的层解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信

但是真正进行通信的是主机的应用进程

![image-20251231153910054](/coding_images/image-20251231153910054.png)

==运输层直接为应用进程间的逻辑通信提供服务==

运输层为应用层提供了两种不同的运输协议，面向连接的TCP和无连接的UDP

### 运输层端口号复用分用

![image-20251231172626760](/coding_images/image-20251231172626760.png)

端口号是用来标识进程的

 ![image-20251231174235290](/coding_images/image-20251231174235290.png)

![image-20251231174318260](/coding_images/image-20251231174318260.png)

 ![image-20251231180339899](/coding_images/image-20251231180339899.png)

![image-20251231180525124](/coding_images/image-20251231180525124.png)

![image-20251231180732999](/coding_images/image-20251231180732999.png)

![image-20251231180809465](/coding_images/image-20251231180809465.png)

### UDP和TCP对比

![image-20251231181418103](/coding_images/image-20251231181418103.png)

UDP（User Datagram Protocol）用户数据报协议UDP

- 直接传输（无连接）
- 支持单播，多播，广播
- 面相应用报文，既不合并也不拆分，加一个UDP首部就可以传输
- 提供不可靠传输服务，会有丢失，误码的情况
- 适用于IP电话，视频会议等实时应用

TCP（Transmission Control Ptrotocol）传输控制协议

- 三次握手四次挥手（面相连接）
- 仅支持单播（创造一个链接信道，然后通信）
- 面相应用进程，接收字节流，然后进入缓存，然后分块进行发送
- 不会有误码，丢失，乱序，重复的传输差错的情况
- 适用于可靠传输应用，例如文件传输

![image-20251231182035757](/coding_images/image-20251231182035757.png)

![image-20251231203434187](/coding_images/image-20251231203434187.png)

![image-20251231203500428](/coding_images/image-20251231203500428.png)

### TCP流量控制

==让发送方的发送速率不要太快，要让接收方来得及接收==

利用**滑动窗口**机制进行流量控制

- `seq`：首个发送数据的第一个编号
- `DATA`：表示发送的是数据
- `ACK == 1`：确认字段
- `ack == 201`：确认序号字段，表示序号201前的数据都已成功节接受
- `rwnd == 300`：将接收窗口改为300

![image-20251231205839330](/coding_images/image-20251231205839330.png)

![image-20251231210305187](/coding_images/image-20251231210305187.png)

防止死锁，就算窗口为0，也要接收零窗口探测报文段 

![image-20251231210648239](/coding_images/image-20251231210648239.png)

### TCP拥塞控制

`拥塞`：对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。

`网络资源`：链路容量，交换节点中缓存和处理机

![image-20260101135440236](/coding_images/image-20260101135440236.png)

TCP拥塞控制算法

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

去除干扰

回到当下

让自己先变得无聊（轻柔的进入工作）

不要矫枉过正

面对分心：休息一下（5分钟or10分钟）不要专注型休息，要发散（发呆）休息，站起来，散散步。

不要让专注力混乱

记录担心的事情，多次回顾

即刻去做

假定条件：

1.数据单方向传送

2.接收方总是有足够大的缓存空间，因而发送方发送串口的大小由网络的拥塞程度决定

3.以tcp最大报文树MSS的个数为单位，而非字节为单位

![image-20260101145602458](/coding_images/image-20260101145602458.png)

![image-20260101150148087](/coding_images/image-20260101150148087.png)

描述：cwnd先指数级上涨，到达慢开始门限的时候，使用拥塞避免算法，每一次cwnd都加一，若期间出现了重传计时器超时的情况，则说明出现了拥塞，将慢开始门限返回为原来的一半，cwnd返回1，再指数级增长，继续循环。

![image-20260101150440171](/coding_images/image-20260101150440171.png)

快重传算法：

注意：这里的顺序，不是指数据本身的顺序，而是指报文与报文之间的顺序。

![image-20260101150621058](/coding_images/image-20260101150621058.png)

eg：

![image-20260101150852951](/coding_images/image-20260101150852951.png)



- `快重传`：个别丢失报文会立即重传，不会超时重传，会提高吞吐量
- `快恢复`：发送方一旦受到3个重复确认，就知道现在只是丢失了个别的报文段。然后不启动慢开始算法，直接执行快恢复算法

四种算法融合的最终算法情况：

![image-20260101151232474](/coding_images/image-20260101151232474.png)

再快恢复之后，cwnd的值改为慢开始门限

### 超时重传时间的选择

==超时重传时间RTO的值如果过小，会导致错误重传，如果过大，时间过长，网络使用效率低下，所以RTO的合适时间应该略大于往返时间RTT==

![image-20260101151855686](/coding_images/image-20260101151855686.png)

![image-20260101151944116](/coding_images/image-20260101151944116.png)

RTT的测量比较复杂，尤其是超时重传的现象发生

**Karn算法：难办就不办了！**

![image-20260101152946081](/coding_images/image-20260101152946081.png)

解释一下karn算法的异常情况：若延时突增的话，按照原始Karn算法，就会出现一直不更新RTT的情况，那RTO就一直不更新，会形成死胡同，一直重传。所以进行了修正，每一次重传都要将RTO增加一些。

![image-20260101153420034](/coding_images/image-20260101153420034.png)

注意：

1.这个计算RTTd的时候使用的RTTs是刚算完的新RTTS

2.要注意有没有重传的现象，如果重传，就不按照公式来了，就直接将RTO*2

### TCP可靠传输的实现

TCP**基于以字节为单位的滑动窗口**

![image-20260102211537738](/coding_images/image-20260102211537738.png)

![image-20260102211812459](/coding_images/image-20260102211812459.png)

 ==接收方只能确认按序数据的最高位==（只能按照顺序接受结果，不能跳着来）

- 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的窗口一样大（因为有时间延迟）
- 对于不按时到达的数据改如何处理？TCP无明确规定
- TCP要求接收方必须有积累确认和捎带确认机制，这样可以减小传输开销。接收方可以在适合的时候发送确认，也可以在自己有数据要发送时候把确认信息顺带捎上。

### TCP运输连接的管理

一、TCP的连接建立

- 建立 - 三次握手
- 数据传输
- 释放 - 四次挥手

**建立**

SYN == 1不能携带数据但是要消耗一个序号

![image-20260102221132188](/coding_images/image-20260102221132188.png)

![image-20260103122746521](/coding_images/image-20260103122746521.png)

**连接释放**：

![image-20260103125732680](/coding_images/image-20260103125732680.png)

###  TCP首部格式

![image-20260103165409665](/coding_images/image-20260103165409665.png)

![image-20260103165607289](/coding_images/image-20260103165607289.png)

![image-20260103165848539](/coding_images/image-20260103165848539.png)

**ACK == 1的时候，确认号才有效，为0的时候无效**

==数据偏移：占据4比特，以4个字节为单位，用来指出TCP报文段的数据载荷部分的起始处距离TCP报文的起始处有多远，实际上指出了TCP报文段的首部长度==

首部固定长度为20字节，因此数据偏移字段的最小值为（0101）（注意以4个字节为单位）

保留字段：暂时不用，占6比特

窗口：占16比特，以字节为单位，指出发送报文的一方的接收窗口，窗口值作为接收方让发送方设置其发送窗口的一句，这是以接收方的接收能力来控制发送方的发送能力，称为流量控制

![image-20260103170521307](/coding_images/image-20260103170521307.png)

SYN :在TCP连接建立时用来同步序号

![image-20260103170625519](/coding_images/image-20260103170625519.png)

FIN:用来释放TCP连接

![image-20260103170659762](/coding_images/image-20260103170659762.png)

RST:用来复位TCP连接，若RST == 1，表明TCP连接出现异常，需要释放连接，然后重新建立连接，还用来拒绝一个非法报文或者拒绝一个TCP连接

PSH：接收方的TCP收到该标志位为1的报文会尽快上交应用进程，而不必等到接收缓存填满之后再上交

紧急标志位URG：URG == 1时，紧急指针字段有效，为0的时候无效。

紧急指针：占16比特，以字节为单位，用来指明紧急数据长度。

![image-20260103171052275](/coding_images/image-20260103171052275.png)

选项：

![image-20260103171148027](/coding_images/image-20260103171148027.png)

填充：保证首部能被4整除

## 应用层

### 基本概念

- 应用层是计算机网络体系结构最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。
- 早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）
- 20世纪90年代将因特网带入千家万户的www（http）
- 当今流行的即时通信，P2P文件共享及音视频应用
- 计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供广阔舞台

### 客户-服务器方式和对等方式（P2P）

- （Client/Server）方式是指通信中所涉及的两个应用进程
- 他们之间是是服务和被服务的关系

CS方式

- 客户是服务请求方，服务器是服务提供方
- 服务器总是处于运行状态，并等待客户的服务请求，服务器具有固定的端口号（HTTP服务一般来说默认为80端口号），而运行服务器的主机也具有固定的IP地址
- 应用：万维网，文件传输FTP、电子邮件

![image-20251113150641149](/coding_images/image-20251113150641149.png)

P2P方式（Peer-to-Peer）

- 没有固定的请求者和提供服务者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等放。对等方之间互相直接通信，每一个对等方既是服务的请求者，又是服务的提供者。
- 主要应用：P2P文件共享，即时通信，流媒体，分布式存储
- 可扩展性极强，系统不会因为规模增大而降低性能
- 成本较低

![image-20251113151439902](/coding_images/image-20251113151439902.png)

### DHCP(动态主机配置协议DHCP)

作用：

- DHCP为网络中的主机提前配置好IP地址，子网掩码，默认网关，DNS服务器等信息

工作过程：

![image-20260103174230650](/coding_images/image-20260103174230650.png)

DHCP服务器和客户都要使用ARP协议

![image-20260103174028222](/coding_images/image-20260103174028222.png)

![image-20260103174343441](/coding_images/image-20260103174343441.png)

上图要路由器需要配置DHCP的IP地址才可以让DHCP工作，这叫中继代理

### DNS(域名系统)

查询域名对应的IP地址（类似于一个映射表）

**层次树状结构的域名结构**：

![image-20260103175806465](/coding_images/image-20260103175806465.png)

![image-20260103175947023](/coding_images/image-20260103175947023.png)

![image-20260103180108561](/coding_images/image-20260103180108561.png)

![image-20260103180320849](/coding_images/image-20260103180320849.png)

**域名解析的过程**：

![image-20260103180604372](/coding_images/image-20260103180604372.png)

- 为了提高DNS查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，**再域名服务器中广泛的使用高速缓存**。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录
- 由于域名到IP 地址的映射关系不是永恒不变的，为了保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的选项。
- 不但在本地域名服务器中需要高速缓存，再用户主机中也很需要缓存，很多用户主机在启动时候从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在缓存中找不到域名时才想域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。

![image-20260103181847345](/coding_images/image-20260103181847345.png)

==DNS报文是封装在UDP报文中的==

### FTP(文件传送协议)

 ![image-20260103191551907](/coding_images/image-20260103191551907.png)

`常见用途`：

- 计算机之间传输文件，尤其是用于批量传输
- 让网站设计者将构成网络内容的大量文件批量上传到Web服务器内

![image-20260103191920144](/coding_images/image-20260103191920144.png)

右边是被动模式

一个是客户开端口，另一个是服务器开端口

![image-20260103192213671](/coding_images/image-20260103192213671.png)

### EMAIL（电子邮件）

![image-20260103192434146](/coding_images/image-20260103192434146.png)

![image-20260103192515045](/coding_images/image-20260103192515045.png)

**SMTP协议基本工作原理：**

![image-20260103192844035](/coding_images/image-20260103192844035.png)

### 万维网（完结撒花）

浏览器最重要的部分是==渲染引擎==，也就是==浏览器内核==。负责对网页内容进行解析和显示。

- 不同的浏览器内核对网页内容的解析也有所不同，因此同一网页在不同内核的浏览器里的显示效果也可能不同。
- 网页编写者需要在不同内核的浏览器中测试网页显示效果。

![image-20260103193842059](/coding_images/image-20260103193842059.png)

### **HTTP**

HTTP/1.0采用的是==非持续连接==方式。在该方式之下，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应之后就立即关闭连接

- ==每请求一个文档就要有2倍RTT时间的开销==，所以一个网页上的多个文档每一个都要花2RTT的时间。
- 为了减少时延，浏览器会并行多个TCP连接请求的多个对象，但是会占用大量的万维网的服务器资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。

![image-20260103194659418](/coding_images/image-20260103194659418.png)

HTTP/1.1采用==持续链接==方式。万维网服务器在发送相应报文的时候继续保持TCP连接，使同一个客户和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而只要这些文档都在同一个服务器上就行。

- 为了进一步提高效率，HTTP/1.1的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的相应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器之后，服务器就发回一个接一个的相应报文。这样就节省了很多个RTT时间，使得TCP连接中的空闲时间减少，提高效率

**HTTP报文格式**

HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，而且每个字段的长度都是不确定的

**请求报文**：

![image-20260103195335249](/coding_images/image-20260103195335249.png)

![image-20260103195342685](/coding_images/image-20260103195342685.png)

**响应报文**：

比响应要多一个状态行

![image-20260103195438754](/coding_images/image-20260103195438754.png)

**常见状态行**：

![image-20260103195528669](/coding_images/image-20260103195528669.png)

cookie机制：

![image-20260103195704164](/coding_images/image-20260103195704164.png)

类似于登录的时候“记住账号密码”

![image-20260103195847008](/coding_images/image-20260103195847008.png)

`setcookie`字段：cookie的唯一标识

**万维网缓存**:

![image-20260103200041795](/coding_images/image-20260103200041795.png)

个人理解： ==本地仓库==

 ![image-20260103201027934](/coding_images/image-20260103201027934.png)

![image-20260103201252804](/coding_images/image-20260103201252804.png)

